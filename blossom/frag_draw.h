// Generated with Shader Minifier 1.3.6 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef FRAG_DRAW_H_
# define FRAG_DRAW_H_
# define VAR_fragColor "f"
# define VAR_iChannel1 "m"
# define VAR_iFrame "i"
# define VAR_iResolution "v"

const char *draw_frag =
 "#version 430\n"
 "layout(location=0) out vec4 f;"
 "layout(location=0) uniform vec4 v;"
 "layout(location=1) uniform int i;"
 "uniform sampler2D m;\n"
 "#define pi acos(-1.)\n"
 "#define tau (pi*2.)\n"
 "float z;"
 "float s()"
 "{"
   "float v=fract(z++*.1031);"
   "v+=v*(v+19.19)*3.;"
   "return fract((v+v)*v);"
 "}"
 "vec2 n()"
 "{"
   "return vec2(s(),s());"
 "}"
 "mat2 n(float v)"
 "{"
   "float m=cos(v),x=sin(v);"
   "return mat2(m,-x,x,m);"
 "}"
 "float n(vec2 v,vec2 z)"
 "{"
   "vec2 m=abs(v)-z;"
   "return length(max(m,0.))+min(max(m.x,m.y),0.);"
 "}"
 "float n(vec3 v,vec3 x)"
 "{"
   "return length(max(abs(v)-x,0.));"
 "}"
 "int a=-1,o=-1;"
 "float s(vec3 v)"
 "{"
   "v.z=abs(v.z)-4.;"
   "v.z=abs(v.z)-2.;"
   "v.z=abs(v.z)-1.;"
   "v.z=abs(v.z)-.5;"
   "v.z=abs(v.z)-.25;"
   "v.y+=sin(v.x*2.)*.05;"
   "return length(v.zy)-.35;"
 "}"
 "float t(vec3 v)"
 "{"
   "float m=abs(v.z)-7.75;"
   "v.x=mod(v.x,pi*.25)-pi*.125;"
   "return max(m,length(v.xy)-.35);"
 "}"
 "float x(vec3 v)"
 "{"
   "float m=n(v.zy,vec2(8,.35));"
   "if(m<1)"
     "{"
       "float a=t(v);"
       "v.z-=.125;"
       "float x=s(v);"
       "v.z+=.25;"
       "float z=s(v*vec3(-1,1,1));"
       "return min(a,min(x,z));"
     "}"
   "return m;"
 "}"
 "float e(vec3 v)"
 "{"
   "vec3 z=v;"
   "float s=v.y+3e2;"
   "v.z=abs(v.z)-20.;"
   "float f=v.y,i=10.;"
   "if(z.z>0.)"
     "i*=.7;"
   "if(v.z<0.)"
     "{"
       "float y=abs(v.z/20.);"
       "f-=sqrt(1.-y*y)*i;"
     "}"
   "else"
     " f-=smoothstep(0.,1.,1.-v.z/80.)*i;"
   "f=max(f,n(z.xz,vec2(75,100)));"
   "if(abs(f)<.1)"
     "f-=(texture(m,z.xz*.015625*.1).x+texture(m,z.xz*.015625*.05).x+texture(m,z.xz*.015625*.025).x)*.02;"
   "v=z;"
   "v.y-=2e2;"
   "float r=length(v)-30.;"
   "r=1e9;"
   "v=z;"
   "v.y-=5.;"
   "v.z-=1.5;"
   "v.y-=(sin(max(v.x*.05,-pi*.5))*.5+.5)*.5;"
   "v.y+=cos(v.z*.5)*.1;"
   "float y=x(v*2.)*.5,l=s;"
   "l=min(l,f);"
   "l=min(l,y);"
   "l=min(l,r);"
   "a=l==s?"
     "0:"
     "l==f?"
       "1:"
       "3;"
   "return l;"
 "}"
 "vec3 h(vec3 v)"
 "{"
   "v=normalize(v);"
   "vec3 z=normalize(cross(vec3(-1),v)),x=normalize(cross(v,z));"
   "vec2 m=n();"
   "m.x=m.x*2.*pi;"
   "m.y=pow(m.y,.5);"
   "float i=sqrt(1.-m.y*m.y);"
   "return cos(m.x)*i*z+sin(m.x)*i*x+m.y*v;"
 "}"
 "vec3 e(vec3 v,vec3 z)"
 "{"
   "vec3 m=mix(vec3(0,.25,1)*.05,vec3(5,4,3)*.25,pow(max(0.,dot(v,z)-.5)*2.,4.));"
   "return mix(m,vec3(dot(m,vec3(.2126,.7152,.0722))),.5);"
 "}"
 "bool e(vec3 v,vec3 m,out vec3 x,out vec3 f,out float z)"
 "{"
   "float i=0.;"
   "for(int r=0;r<100;++r)"
     "{"
       "z=e(v+m*i);"
       "if(abs(z)<.001)"
         "break;"
       "i+=z;"
     "}"
   "x=v+m*i;"
   "if(abs(z)<.001)"
     "{"
       "vec2 l=vec2(.001,0);"
       "f=normalize(vec3(e(x+l.xyy)-z,e(x+l.yxy)-z,e(x+l.yyx)-z));"
       "return true;"
     "}"
   "return false;"
 "}"
 "float e(float v,float m,float z)"
 "{"
   "z=clamp(z,v,m);"
   "return(z-v)/(m-v);"
 "}"
 "vec2 p(vec2 v)"
 "{"
   "vec2 m=vec2(110,50),z=vec2(10,-50);"
   "return vec2(e(z.x,m.x,v.x),e(z.y,m.y,v.y));"
 "}"
 "vec3 h(vec3 v,vec3 z)"
 "{"
   "vec3 x=normalize(vec3(0,.5,-.8)),i=vec3(1);"
   "for(int f=0;f<5;++f)"
     "{"
       "vec3 l,y;"
       "float r;"
       "if(e(v,z,l,y,r))"
         "{"
           "o=a;"
           "v=l+y*.01;"
           "if(a==0)"
             "z=h(y),i*=.8;"
           "else if(a==1)"
             "{"
               "z=h(y);"
               "vec3 n=vec3(211,183,155)/255.;"
               "n=mix(n,vec3(1),.25);"
               "i*=n*n*n;"
               "vec2 t=p(l.zx);"
               "i*=texture(m,t).z;"
             "}"
           "else if(a==3)"
             "{"
               "float n=pow(1.-min(.99,dot(-z,y)),5.);"
               "n=mix(.04,1.,n);"
               "if(s()<n)"
                 "z=reflect(z,y);"
               "else"
                 " z=h(y),i*=vec3(120,2,0)/255.;"
             "}"
         "}"
       "else if(abs(r)>.1)"
         "return e(x,z)*i;"
       "else"
         " break;"
     "}"
   "return e(x,z)*i;"
 "}"
 "vec2 e()"
 "{"
   "vec2 v=n();"
   "v.x=v.x*3.-1.;"
   "v-=step(1.,v.x+v.y);"
   "v.x+=v.y*.5;"
   "v.y*=sqrt(.75);"
   "return v;"
 "}"
 "void main()"
 "{"
   "z=float((i*73856093^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);"
   "vec2 m=(gl_FragCoord.xy+n()*1.5-.75)/v.xy-.5;"
   "float x=v.x/v.y;"
   "m.x*=x;"
   "m*=max(1.,1.5/x);"
   "const vec3 a=vec3(200,150,79),y=vec3(0,2,39);"
   "const vec2 l=vec2(1)*1.5;"
   "vec3 r=vec3(0),o=normalize(vec3(m,3.7));"
   "vec2 s=e();"
   "r.xy+=s*l;"
   "o.xy-=s*l*o.z/(distance(a,y)*.99);"
   "vec3 d=y-a;"
   "float t=-atan(d.y,length(d.xz)),g=-atan(d.x,d.z);"
   "r.yz*=n(t);"
   "o.yz*=n(t);"
   "r.xz*=n(g);"
   "o.xz*=n(g);"
   "r+=a;"
   "vec3 c=h(r,o);"
   "f=!isnan(c.x)&&c.x>=0.?"
     "vec4(c,1):"
     "vec4(0);"
 "}";

#endif // FRAG_DRAW_H_
