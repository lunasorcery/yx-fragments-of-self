// Generated with Shader Minifier 1.3.6 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef FRAG_DRAW_H_
# define FRAG_DRAW_H_
# define VAR_fragColor "f"
# define VAR_iChannel1 "m"
# define VAR_iFrame "i"
# define VAR_iResolution "v"

const char *draw_frag =
 "#version 430\n"
 "layout(location=0) out vec4 f;"
 "layout(location=0) uniform vec4 v;"
 "layout(location=1) uniform int i;"
 "uniform sampler2D m;\n"
 "#define pi acos(-1.)\n"
 "#define tau (pi*2.)\n"
 "float x;"
 "float s()"
 "{"
   "float v=fract(x++*.1031);"
   "v+=v*(v+19.19)*3.;"
   "return fract((v+v)*v);"
 "}"
 "vec2 n()"
 "{"
   "return vec2(s(),s());"
 "}"
 "mat2 n(float v)"
 "{"
   "float m=cos(v),x=sin(v);"
   "return mat2(m,-x,x,m);"
 "}"
 "float n(vec2 v,vec2 x)"
 "{"
   "vec2 m=abs(v)-x;"
   "return length(max(m,0.))+min(max(m.x,m.y),0.);"
 "}"
 "float n(vec3 v,vec3 x)"
 "{"
   "return length(max(abs(v)-x,0.));"
 "}"
 "int a=-1,z=-1;"
 "float s(vec3 v)"
 "{"
   "v.y+=texture(m,v.xz*.015625*.02).x*.05-.025;"
   "v.z=abs(v.z)-4.;"
   "v.z=abs(v.z)-2.;"
   "v.z=abs(v.z)-1.;"
   "v.z=abs(v.z)-.5;"
   "v.z=abs(v.z)-.25;"
   "v.y+=sin(v.x*2.)*.05;"
   "return length(v.zy)-.35;"
 "}"
 "float t(vec3 v)"
 "{"
   "float m=abs(v.z)-7.75;"
   "v.x=mod(v.x,pi*.25)-pi*.125;"
   "return max(m,length(v.xy)-.35);"
 "}"
 "float e(vec3 v)"
 "{"
   "float m=n(v.zy,vec2(8,.35));"
   "if(m<1)"
     "{"
       "float x=t(v);"
       "v.z-=.125;"
       "float a=s(v);"
       "v.z+=.25;"
       "float z=s(v*vec3(-1,1,1));"
       "return min(x,min(a,z));"
     "}"
   "return m;"
 "}"
 "float p(vec3 v)"
 "{"
   "vec3 x=v;"
   "float z=v.y+3e2;"
   "v.z=abs(v.z)-20.;"
   "float f=v.y,i=10.;"
   "if(x.z>0.)"
     "i*=.7;"
   "if(v.z<0.)"
     "{"
       "float y=abs(v.z/20.);"
       "f-=sqrt(1.-y*y)*i;"
     "}"
   "else"
     " f-=smoothstep(0.,1.,1.-v.z/80.)*i;"
   "f=max(f,n(x.xz,vec2(75,100)));"
   "if(abs(f)<.1)"
     "f-=(texture(m,x.xz*.015625*.1).x+texture(m,x.xz*.015625*.05).x+texture(m,x.xz*.015625*.025).x)*.02;"
   "v=x;"
   "v.y-=2e2;"
   "float r=length(v)-30.;"
   "r=1e9;"
   "v=x;"
   "v.x=-v.x;"
   "v.y-=5.;"
   "v.z-=1.5;"
   "v.y+=(sin(min(v.x*.07+3.,pi*.5))*.5-.5)*2.;"
   "v.y+=cos(v.z*.5)*.1;"
   "v.y-=.4;"
   "v.yz*=n(max((-v.x+30.)*.005,0.)-.1);"
   "float y=e(v*2.)*.5,s=z;"
   "s=min(s,f);"
   "s=min(s,y);"
   "s=min(s,r);"
   "a=s==z?"
     "0:"
     "s==f?"
       "1:"
       "3;"
   "return s;"
 "}"
 "vec3 h(vec3 v)"
 "{"
   "v=normalize(v);"
   "vec3 x=normalize(cross(vec3(-1),v)),z=normalize(cross(v,x));"
   "vec2 m=n();"
   "m.x=m.x*2.*pi;"
   "m.y=pow(m.y,.5);"
   "float i=sqrt(1.-m.y*m.y);"
   "return cos(m.x)*i*x+sin(m.x)*i*z+m.y*v;"
 "}"
 "vec3 e(vec3 v,vec3 x)"
 "{"
   "vec3 m=mix(vec3(0,.25,1)*.05,vec3(5,4,3)*.25,pow(max(0.,dot(v,x)-.5)*2.,4.));"
   "return mix(m,vec3(dot(m,vec3(.2126,.7152,.0722))),.5);"
 "}"
 "bool e(vec3 v,vec3 m,out vec3 x,out vec3 f,out float a)"
 "{"
   "float z=0.;"
   "for(int r=0;r<100;++r)"
     "{"
       "a=p(v+m*z);"
       "if(abs(a)<.001)"
         "break;"
       "z+=a;"
     "}"
   "x=v+m*z;"
   "if(abs(a)<.001)"
     "{"
       "vec2 s=vec2(.001,0);"
       "f=normalize(vec3(p(x+s.xyy)-a,p(x+s.yxy)-a,p(x+s.yyx)-a));"
       "return true;"
     "}"
   "return false;"
 "}"
 "float e(float v,float m,float x)"
 "{"
   "x=clamp(x,v,m);"
   "return(x-v)/(m-v);"
 "}"
 "vec2 c(vec2 v)"
 "{"
   "vec2 m=vec2(110,50),x=vec2(10,-50);"
   "return vec2(e(x.x,m.x,v.x),e(x.y,m.y,v.y));"
 "}"
 "vec3 c(vec3 v,vec3 x)"
 "{"
   "vec3 f=normalize(vec3(0,.5,-.8)),i=vec3(1);"
   "for(int r=0;r<5;++r)"
     "{"
       "vec3 y,p;"
       "float l;"
       "if(e(v,x,y,p,l))"
         "{"
           "z=a;"
           "v=y+p*.01;"
           "if(a==0)"
             "x=h(p),i*=.8;"
           "else if(a==1)"
             "{"
               "x=h(p);"
               "vec3 n=vec3(211,183,155)/255.;"
               "n=mix(n,vec3(1),.25);"
               "i*=n*n*n;"
               "vec2 o=c(y.zx);"
               "i*=texture(m,o).z;"
             "}"
           "else if(a==3)"
             "{"
               "float n=pow(1.-min(.99,dot(-x,p)),5.);"
               "n=mix(.04,1.,n);"
               "if(s()<n)"
                 "x=reflect(x,p);"
               "else"
                 " x=h(p),i*=vec3(60,1,3)/255.;"
             "}"
         "}"
       "else if(abs(l)>.1)"
         "return e(f,x)*i;"
       "else"
         " break;"
     "}"
   "return e(f,x)*i;"
 "}"
 "vec2 c()"
 "{"
   "vec2 v=n();"
   "v.x=v.x*3.-1.;"
   "v-=step(1.,v.x+v.y);"
   "v.x+=v.y*.5;"
   "v.y*=sqrt(.75);"
   "return v;"
 "}"
 "void main()"
 "{"
   "x=float((i*73856093^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);"
   "vec2 m=(gl_FragCoord.xy+n()*1.5-.75)/v.xy-.5;"
   "float z=v.x/v.y;"
   "m.x*=z;"
   "m*=max(1.,1.5/z);"
   "const vec3 a=vec3(200,150,79),y=vec3(0,2,39);"
   "const vec2 s=vec2(1)*1.5;"
   "vec3 r=vec3(0),p=normalize(vec3(m,3.7));"
   "vec2 t=c();"
   "r.xy+=t*s;"
   "p.xy-=t*s*p.z/(distance(a,y)*.99);"
   "vec3 l=y-a;"
   "float o=-atan(l.y,length(l.xz)),d=-atan(l.x,l.z);"
   "r.yz*=n(o);"
   "p.yz*=n(o);"
   "r.xz*=n(d);"
   "p.xz*=n(d);"
   "r+=a;"
   "vec3 g=c(r,p);"
   "f=!isnan(g.x)&&g.x>=0.?"
     "vec4(g,1):"
     "vec4(0);"
 "}";

#endif // FRAG_DRAW_H_
